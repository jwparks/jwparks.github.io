---
title:  "레이트레이싱: 빛과 그래픽스"
mathjax: true
layout: post
categories: Dev
---
안녕하세요, 2023년도 겨울학기 과학계산 트레이닝 세션의 두번째 주제는 컴퓨터를 이용해 빛을 추적하는 기법인 **Ray tracing** 입니다. 
이번 주제는 첫 주차 주제보다 수학적인 요소도 많고, 이를 컴퓨터를 이용하여 구현하는 것도 조금 더 어려운데요. 
대신 그만큼 더 재미있는 주제라고 생각 합니다. 
이번 주차를 수행하며 여러분은 실제로 현대 컴퓨터 그래픽스에서 널리 쓰이는 렌더링 방법중 하나인 레이트레이싱을 파이썬을 이용해 직접 구현하게 됩니다.
이를 구현하는 과정에서 여러분은 공간 벡터의 개념과 구현 및 응용 그리고 객체지향 프로그래밍을 연습 할 수 있습니다.

## Learning objectives
이번 주차의 학습 목표는 다음과 같습니다.
- 그래픽 렌더링 방법인 레이트레이싱의 개념을 이해합니다.
- 컴퓨터 프로그래밍을 통해 빛과 객체의 요소들을 수학적으로 정의한 공간 벡터를 구현합니다.

또한 공식적인 학습 목표는 아니지만 이번 주차의 학습을 진행하며 수학적으로 정의되는 **수식**과 이를 컴퓨터로 구현하는 **프로그래밍 코드** 사이의 관계가 익숙해질 거라고 기대하고 있습니다.  


## Introduction

우리가 시각 시스템을 통해 물체를 볼 수 있는 원리는 무엇일까요?
많은 분들이 답을 잘 알고 계시겠지만 우리는 눈으로 들어오는 빛, 즉 광선을 통해서 물체를 볼 수 있습니다. 
태양, 전구 등 광원(Light source)에서 나온 빛이 물체에 반사되고, 물체가 가진 물리적인 특성에 따라 광선의 파장이 바뀌고, 바뀐 광선의 파장을 통해 우리는 물체를 볼 수 있습니다.

레이트레이싱, 우리말로 광선추적 기법은 컴퓨터 그래픽의 렌더링 기법중 하나로, 
우리가 빛을 통해 물체를 볼 수 있는 원리를 컴퓨터를 이용해 직관적으로 구현하는 기법입니다.
실제로 다른 점이 있다면 광원에서 나온 빛을 추적하는 것이 아니라 이미지로 들어오는 빛을 역추적 하는 기법이라는 차이가 있습니다.
다른 렌더링 기법 대비 레이트레이싱의 장점은 **매우 현실적인 그래픽**을 렌더링 할 수 있다는 장점이 있습니다.
당연히 실제 현실의 물리계에서 일어나는 빛의 반사를 가장 직관적으로 구현한 기법이기 때문에 현실적인 그래픽을 만들 수 있습니다.
반면 단점은 이미지를 구성하기 위해 필요한 수 많은 광선 다발을 추적해야 하기 때문에 극도로 높은 컴퓨터 자원을 필요로 합니다. 
그래서 레이트레이싱은 1980년대 제안된 매우 오래된 컴퓨터 그래픽스 기법이지만, 그동안은 매우 제한된 환경에서만 활용되어 왔습니다. 
그래픽을 실시간으로 렌더링해야 하는 비디오 게임 등에서는 거의 사용되지 않았고, 미리 렌더링을 해서 보여 줄 수 있는 영화, 애니메이션 등에서 주로 활용되어 왔습니다.
하지만 현대 컴퓨터 하드웨어의 발전을 통해 가정용 컴퓨터에 들어가는 그래픽카드들이 레이트레이싱 전용 직접회로인 RT 코어를 탑재하며
실시간 렌더링을 필요로 하는 비디오 게임 등에서도 제한적으로 레이트레이싱 기법이 활용되고 있습니다. 
아마 컴퓨터를 잘 모르시는 분들도 그래픽카드 모델명이 RTX3070이다, RTX4080이다 이런 말들을 들어 보셨을 텐데요, 이렇게 RTX 이름을 달고 있는 그래픽카드들이 바로 RT 코어를 내장하고 있는 그래픽카드들 입니다.

![RaytracingComparison](assets/images/raytracing/Control-RTX-Comparison-6.jpg)

초당 수십장의 프레임을 렌더링 하는 비디오 게임에서 사용되는 실시간 레이트레이싱 기법은 아직 부족한 점이 많음에도 불구하고,
2019년 출시된 비디오 게임인 "Control"에서 기존 렌더링 기법(왼쪽)과 실시간 레이트레이싱(오른쪽)을 비교해 보면 빛의 반사와 사물의 그림자에서 확연한 차이가 나는 것을 볼 수 있습니다.
이처럼 레이트레이싱은 빛이 반사되어 생기는 상, 가려서 생기는 그림자 등을 매우 현실적으로 렌더링 할 수 있는 기법입니다. 

최근엔 많은 게임 엔진과 렌더링 엔진 등에서 레이트레이싱을 기본 옵션으로 제공하고 있어 손쉽게 구현이 가능합니다. 하지만 우리는 `python`과 `numpy`등 기본적인 과학계산 라이브러리만을 이용하여 실제 레이트레이싱을 밑바닥부터 구현해 보도록 하겠습니다. 

> Quiz 1. 레이트레이싱 기법은 왜 광원으로부터 나오는 광선을 직접 추적하지 않고, 이미지로 들어오는 빛을 역추적 할까요?

## Python을 이용한 레이트레이싱 구현
### 문제와 좌표계를 정의하기
흥미로운 주제가 정해 졌으니 이제 문제와 좌표계를 정의할 차례 입니다. 우리는 궁극적으로 레이트레이싱 기법을 이용하여 2D 이미지를 렌더링 하기를 원합니다. 
2D 이미지를 렌더링 한다는 의미는, 이미지를 구성하는 픽셀들의 색을 "적절히" 칠한다는 것을 의미합니다. 
그리고 우리는 각 픽셀들의 색이 그 픽셀로 들어온 광선으로부터 정의될 것이라는 사실을 알고 있습니다.

![1](assets/images/raytracing/1.png)

위 그림에서는 2D 이미지(프레임)인 `Scene`의 픽셀 $P(a)$, $P(b)$, $P(c)$를 각가 통과하는 세개의 광선 $R(a)$, $R(b)$, $R(c)$이 그려져 있습니다.
광선 $R(a)$의 경우 정의된 물체인 파란색 구에서 반사되어 광원을 향하고 있습니다. 이 경우 우리는 픽셀 $P(a)$를 어떤 색으로 칠해야 할까요? 
광선 $R(a)$가 파란색 구에 닿는 부분은 상대적으로 밝을 것이기 때문에 우리는 밝은 색을 칠해주면 됩니다. 그림에서는 $P(a)$의 색이 흰색으로 표기 되어 있습니다. 
마찬가지로 픽셀 `$(b)$를 통과하는 광선 $R(b)$는 빛이 물체에 닿고 빈 공간 어딘가로 반사가 될 것입니다. 광원을 직접적으로 향하지 않기 때문에 픽셀 $P(b)$는 물체의 색인 파란색을 띄게 될 것입니다.
마지막으로 픽셀 $P(c)$를 지나는 광선 $R(c)$는 바닥 면에서 반사되어 어딘가로 반사가 될 것이지만, 광원이 물체에 가려져 있습니다. 
이 경우에 물체의 그림자가 생기게 되는데, 광선 $R(c)$는 그림자가 생기는 위치를 향하고 있기 때문에 픽셀 $P(c)$는 어두운 색을 띄게 될 것입니다.

이렇게 레이트레이싱을 통한 렌더링을 구현하기 위해선 우리의 시점(카메라)로부터 `Scene`의 픽셀을 통과하는 각 광선들이 결국 물체의 어떤 부분에 부딪히는지를 계산하고, 
이를 통해 각 픽셀의 색을 결정하면 됩니다. 문제를 정의해 보니 정말 간단하죠?

### 광선 벡터
우리는 이미지를 구성하는 픽셀의 수 만큼 광선을 추적 해야 합니다. 
만약 Full HD 해상도의 이미지 한 장을 렌더링 한다고 가정하면 가로(1920), 세로(1080) 픽셀을 모두 고려하여 총 2,073,600개의 광선을 정의하고 추적해야 합니다.
이러한 광선들은 시작점과 방향이 있는 객체들로 정의하고 구현 할 수 있는데요. 문제는 각 광선들이 향하는 방향이 모두 다르다는 것 입니다.

그래서 우리는 시점(카메라의 위치)으로부터 2D 이미지의 각 픽셀들을 통과하는 광선의 공간 벡터의 방향을 계산해야 합니다.
카메라의 위치 $\vec{C_0}(x,y,z)$와 방향 $\vec{C_d}(x,y,z)$, 카메라의 시야각($\text{FOV(\theta)}$)이 정해지면 각 픽셀을 통과하는 광선들의 공간 벡터의 방향을 계산 할 수 있습니다. 
물론 카메라는 렌즈를 통과하는 회전축을 중심으로 회전(`roll`)이 가능한데, 이 경우는 카메라의 위쪽이 항상 $\hat{z}$ 방향을 향한다고 가정하여 카메라의 `roll` 방향 회전은 고려하지 않겠습니다.

$$ i\hbar\frac{\partial}{\partial t} \Psi(\mathbf{r},t) = \left [ \frac{-\hbar^2}{2\mu}\nabla^2 + V(\mathbf{r},t)\right ] \Psi(\mathbf{r},t) $$

![2](assets/images/raytracing/2.png)

